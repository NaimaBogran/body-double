<!DOCTYPE html>
<html lang="en">
<head>
    <%- include("partials/loggedInHeader") %>

<style>
/* ===============================
        VIDEO LAYOUT
================================ */
#video-wrapper {
    display: flex;
    justify-content: center;
    align-items: center;
    gap: 35px;
    margin-top: 40px;
    flex-wrap: wrap;
}

.video-box {
    width: 430px;
    height: 330px;
    background: #000000;
    border-radius: 18px;
    overflow: hidden;
    position: relative;
    display: flex;
    justify-content: center;
    align-items: center;
}

.video-box video {
    width: 100%;
    height: 100%;
    object-fit: cover;
}

.video-label {
    position: absolute;
    top: 10px;
    left: 12px;
    color: white;
    font-weight: bold;
    font-size: 20px;
    text-shadow: 0 0 5px black;
}

/* ===============================
            TIMER
================================ */
#timer {
    background: #ffffff;
    padding: 20px 25px;
    border-radius: 12px;
    font-size: 25px;
    font-weight: bold;
    text-align: center;
    box-shadow: 0 0 15px rgba(0,0,0,0.15);
    min-width: 110px;
    border: 2px solid lightgray;
}

/* ===============================
            CHAT 
================================ */
#chat-section {
    width: 100%;
    max-width: 900px;
    margin: 40px auto 0 auto;
}

#messages {
    list-style: none;
    padding: 15px;
    margin-bottom: 15px;
    height: 180px;
    overflow-y: auto;
    border-radius: 18px;
    background: #000;
    color: white;
    border: 2px solid #333;
}

#messages p {
    margin: 5px 0;
    padding: 6px 10px;
    background: #222;
    border-radius: 8px;
}

/* Chat form */
#chat-form {
    display: flex;
    gap: 12px;
}

#chat-input {
    flex: 1;
    padding: 12px;
    border-radius: 12px;
    border: 1px solid #555;
    background: #111;
    color: white;
}

#sendBtn {
    padding: 12px 18px;
    background: #333294;
    border: none;
    border-radius: 12px;
    color: white;
    cursor: pointer;
    font-weight: bold;
}

/* Bottom controls */
#findNewBtn {
    margin-top: 25px;
    padding: 14px 24px;
    background: #bfa0fe;
    border: none;
    border-radius: 12px;
    font-weight: bold;
    cursor: pointer;
    font-size: 20px;
}
</style>
</head>

<body style="margin-top: 200px;">

<h1 style="text-align:center; margin-top: 20px;">
    focus session with <%= partnerName %>
</h1>

<p style="text-align:center;">stay focused together for 25 minutes, then enjoy a 5 minute solo break!</p>


<!-- ===============================
          VIDEO + TIMER
================================ -->
<section id="video-wrapper">
    <div class="video-box">
        <p class="video-label">you</p>
        <div class="video-container card">
        <video id="localVideo" autoplay playsinline></video>
        </div>
    </div>

    <div id="timer">25:00</div>

    <div class="video-box">
        <p class="video-label"><%= partnerName %></p>
        <div class="video-container card">
        <video id="remoteVideo" autoplay playsinline></video>
        </div>
    </div>
</section>


<!-- ===============================
            CHAT SECTION
================================ -->
<section id="chat-section">

    <ul id="messages"></ul>

    <form id="chat-form" autocomplete="off">
        <input id="chat-input" placeholder="type a message..." />
        <button id="sendBtn" type="submit">send</button>
    </form>
<div style="display: flex; align-items: center; justify-content: center;">
    <button id="findNewBtn" class="btn btn-primary" >
        find new double
    </button>
</div>
</section>


<%- include("partials/footer") %>
<script src="/socket.io/socket.io.js"></script>
<script>
const socket       = io();

const roomId       = "<%= roomId %>";
const myName       = "<%= user.userName %>";
const partnerName  = "<%= partnerName %>";
const isCaller     = "<%= isCaller %>" === "true";
const isFresh      = new URLSearchParams(window.location.search).get("fresh");

console.log("videoChat → roomId:", roomId, "isCaller:", isCaller, "isFresh:", isFresh);

const localVideoEl  = document.getElementById("localVideo");
const remoteVideoEl = document.getElementById("remoteVideo");
const form          = document.getElementById("chat-form");
const input         = document.getElementById("chat-input");
const messages      = document.getElementById("messages");
const timerEl       = document.getElementById("timer");

let localStream        = null;
let peerConnection     = null;

// hard reset
function fullDisconnect() {
    try {
        if (peerConnection) {
            peerConnection.ontrack = null;
            peerConnection.onicecandidate = null;
            peerConnection.close();
        }
    } catch (e) {
        console.error("peerConnection cleanup error:", e);
    }
    peerConnection = null;

    if (localStream) {
        localStream.getTracks().forEach(track => track.stop());
    }

    localStream = null;

     if (localVideoEl) {
        localVideoEl.srcObject = null;
        localVideoEl.removeAttribute("srcObject");
        localVideoEl.load();   // forces video element reset on mobile
    }

    if (remoteVideoEl) {
        remoteVideoEl.srcObject = null;
        remoteVideoEl.removeAttribute("srcObject");
        remoteVideoEl.load();
    }
}

// handle "find new double" button (leave current partner, look for a new one)
document.getElementById("findNewBtn").addEventListener("click", () => {
    // clean up WebRTC locally
    fullDisconnect();

    // tell server we are intentionally leaving this session
    socket.emit("leavingSession", { roomId });

    // go back to the match page to find someone new
    window.location.href = "/match";
});

if (isFresh) {
    fullDisconnect();
}

// join room
socket.emit("joinRoom", { roomId });

// server may ask us to reset before reconnect
socket.on("prepareForReconnect", () => {
    console.log("prepareForReconnect from server");
    fullDisconnect();
});

/* =============================
         CHAT
============================= */
if (form) {
    form.addEventListener("submit", (e) => {
        e.preventDefault();
        const message = input.value.trim();
        if (!message) return;

        socket.emit("chatMessage", {
            roomId,
            message,
            senderName: myName
        });

        input.value = "";
    });
}

socket.on("chatMessage", ({ message, senderName }) => {
    if (!messages) return;
    const p = document.createElement("p");
    p.textContent = `${senderName}: ${message}`;
    messages.appendChild(p);
    messages.scrollTop = messages.scrollHeight;
});

/* =============================
       PARTNER DISCONNECT
============================= */
socket.on("partnerDisconnected", () => {
    fullDisconnect();
    alert("your partner disconnected :(");
    window.location.href = "/match";
});

/* =============================
         TIMER
============================= */

let focusSeconds = 0.5 * 60; // 30s for testing; change to 25 * 60 for real

function updateFocusTimer() {
    const mins = String(Math.floor(focusSeconds / 60)).padStart(2, "0");
    const secs = String(focusSeconds % 60).padStart(2, "0");
    timerEl.textContent = `${mins}:${secs}`;

    if (focusSeconds <= 0) {
        fullDisconnect();
        socket.emit("goingOnBreak", { roomId });
        window.location.href =
          `/break?roomId=${encodeURIComponent(roomId)}&partnerName=${encodeURIComponent(partnerName)}&mode=video`;
    } else {
        focusSeconds--;
    }
}

updateFocusTimer();
setInterval(updateFocusTimer, 1000);

/* =============================
       WEBRTC SETUP
============================= */

let rtcConfig = {
    iceServers: [
        { urls: "stun:global.stun.twilio.com:3478" },
        {
            urls: "turn:global.turn.twilio.com:3478?transport=udp",
            username: "9c48286eb70ac16f58c5f0f93bea20fc9bd860",
            credential: "QGFX3HTGX5Bk3abs8j0/xWBBCXSppIGiaP29/PiKxXc="
        },
        {
            urls: "turn:global.turn.twilio.com:3478?transport=tcp",
            username: "9c48286eb70ac16f58c5f0f93bea20fc9bd860",
            credential: "QGFX3HTGX5Bk3abs8j0/xWBBCXSppIGiaP29/PiKxXc="
        },
        {
            urls: "turn:global.turn.twilio.com:443?transport=tcp",
            username: "9c48286eb70ac16f58c5f0f93bea20fc9bd860",
            credential: "QGFX3HTGX5Bk3abs8j0/xWBBCXSppIGiaP29/PiKxXc="
        }
    ]
};

async function setupLocalMedia() {
    try {
        localStream = await navigator.mediaDevices.getUserMedia({
            video: {
                facingMode: "user",
                width: { ideal: 1280 },
                height: { ideal: 720 }
            },
            audio: {
                echoCancellation: true,
                noiseSuppression: true,
                sampleRate: 44100
            }
        });

        localVideoEl.srcObject = localStream;
        localVideoEl.muted = true;

        if (isCaller) {
            await startCallAsCaller();
        } else {
            console.log("callee: waiting for offer");
        }
    } catch (err) {
        console.error("Error accessing camera/mic:", err);
        alert("Could not access camera/microphone. Please check your permissions.");
    }
}

function createPeerConnection() {
    if (peerConnection) return;

    peerConnection = new RTCPeerConnection(rtcConfig);

    peerConnection.onicecandidate = (e) => {
        if (e.candidate) {
            socket.emit("iceCandidate", { roomId, candidate: e.candidate });
        }
    };

    peerConnection.ontrack = (e) => {
        remoteVideoEl.srcObject = e.streams[0];
    };

    if (localStream) {
        localStream.getTracks().forEach((track) => {
            peerConnection.addTrack(track, localStream);
        });
    }
}

// caller: create offer
async function startCallAsCaller() {
    createPeerConnection();

    const offer = await peerConnection.createOffer();
    await peerConnection.setLocalDescription(offer);

    socket.emit("offer", { roomId, offer });
}

// callee: receive offer → create answer
socket.on("offer", async ({ offer }) => {
    if (isCaller) return;

    if (!localStream) {
        // ensure camera is ready before responding
        await setupLocalMedia();
    }

    createPeerConnection();

    await peerConnection.setRemoteDescription(offer);

    const answer = await peerConnection.createAnswer();
    await peerConnection.setLocalDescription(answer);

    socket.emit("answer", { roomId, answer });
});

// caller: receive answer
socket.on("answer", async ({ answer }) => {
    if (!peerConnection) return;
    await peerConnection.setRemoteDescription(answer);
});

// both: handle ICE candidates
socket.on("iceCandidate", async ({ candidate }) => {
    if (peerConnection && candidate) {
        try {
            await peerConnection.addIceCandidate(candidate);
        } catch (err) {
            console.error("Error adding ICE candidate:", err);
        }
    }
});

// unload cleanup
window.addEventListener("beforeunload", fullDisconnect);

 if (localVideoEl) {
        localVideoEl.srcObject = null;
        localVideoEl.removeAttribute("srcObject");
        localVideoEl.load();   // forces video element reset on mobile
    }

    if (remoteVideoEl) {
        remoteVideoEl.srcObject = null;
        remoteVideoEl.removeAttribute("srcObject");
        remoteVideoEl.load();
    }
    
// start camera/mic
if (isCaller) {
    setupLocalMedia();
} else {
    // slight delay for callee so caller can be ready
    setTimeout(() => setupLocalMedia(), 300);
}
</script>


</body>
</html>